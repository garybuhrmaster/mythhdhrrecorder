#!/usr/bin/env python3

#
# Copyright (c) 2016, 2017, 2018 Gary Buhrmaster <gary.buhrmaster@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import sys
import threading
import time
import requests
import json
import re
import queue
import argparse
import socket
import os
import io
import datetime
import ipaddress
import zlib
import struct
import urllib


# Logging is "complicated" because (a) we are running
# in python3, so as of now the existing MythTV logging
# class is not available, and (b), the existing MythTV
# logging class has not been updated for more recent
# logging changes (i.e. it does not support the dblog
# changes, nor systemd-journal logging), and (c) one
# cannot log to stdout in any case (stdout has been
# stolen by the transport stream for the External
# Recoder).  So, while we will try to import the
# (hoped for) eventual new version of the logging class,
# we will provide an adequate 'stub' for now (probably
# 90% borrowed from the existing MythTV.logging class).

try:
    import MythTV.logging
except ImportError:

    import syslog
    import systemd.journal

    class LOGMASK(object):
        ALL         = 0b111111111111111111111111111
        MOST        = 0b011111111110111111111111111
        NONE        = 0b000000000000000000000000000

        GENERAL     = 0b000000000000000000000000001
        RECORD      = 0b000000000000000000000000010
        PLAYBACK    = 0b000000000000000000000000100
        CHANNEL     = 0b000000000000000000000001000
        OSD         = 0b000000000000000000000010000
        FILE        = 0b000000000000000000000100000
        SCHEDULE    = 0b000000000000000000001000000
        NETWORK     = 0b000000000000000000010000000
        COMMFLAG    = 0b000000000000000000100000000
        AUDIO       = 0b000000000000000001000000000
        LIBAV       = 0b000000000000000010000000000
        JOBQUEUE    = 0b000000000000000100000000000
        SIPARSER    = 0b000000000000001000000000000
        EIT         = 0b000000000000010000000000000
        VBI         = 0b000000000000100000000000000
        DATABASE    = 0b000000000001000000000000000
        DSMCC       = 0b000000000010000000000000000
        MHEG        = 0b000000000100000000000000000
        UPNP        = 0b000000001000000000000000000
        SOCKET      = 0b000000010000000000000000000
        XMLTV       = 0b000000100000000000000000000
        DVBCAM      = 0b000001000000000000000000000
        MEDIA       = 0b000010000000000000000000000
        IDLE        = 0b000100000000000000000000000
        CHANNELSCAN = 0b001000000000000000000000000
        SYSTEM      = 0b010000000000000000000000000
        TIMESTAMP   = 0b100000000000000000000000000

    class LOGLEVEL(object):
        ANY         = -1
        EMERG       = 0
        ALERT       = 1
        CRIT        = 2
        ERR         = 3
        WARNING     = 4
        NOTICE      = 5
        INFO        = 6
        DEBUG       = 7
        UNKNOWN     = 8

    class LOGFACILITY(object):
        KERN        = 1
        USER        = 2
        MAIL        = 3
        DAEMON      = 4
        AUTH        = 5
        LPR         = 6
        NEWS        = 7
        UUCP        = 8
        CRON        = 9
        LOCAL0      = 10
        LOCAL1      = 11
        LOCAL2      = 12
        LOCAL3      = 13
        LOCAL4      = 14
        LOCAL5      = 15
        LOCAL6      = 16
        LOCAL7      = 17

    class MythLog(LOGLEVEL, LOGMASK, LOGFACILITY):

        def __init__(self, module='pythonbindings', db=None):
            self._module = module
            self._db = db
            self._parseinput = self._noop

        def _noop(self):
            pass

        def _initlogger(self):
            self._initlogger = self._noop
            self._MASK = LOGMASK.GENERAL
            self._LEVEL = LOGLEVEL.DEBUG
            self._LOGSTREAM = None
            self._logwrite = self._logdummy
            self._QUIET = 1
            self._DBLOG = False
            self._SYSLOG = None
            self._lock = threading.Lock()
            self._parseinput()

        def _logdummy(self, mask, level, message, detail=None):
            return

        def _logstream(self, mask, level, message, detail=None):
            self._LOGSTREAM.write('{0} {3} [{1}] {2} ' \
                    .format(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'),
                      os.getpid(), self._module,
                      ['!','A','C','E','W','N','I','D'][level]) + 
                      message + (' -- {0}'.format(detail) if detail else '') + '\n')
            self._LOGSTREAM.flush()
            return

        def _logsyslog(self, mask, level, message, detail=None):
            syslog.syslog(message + (' -- {0}'.format(detail) if detail else ''))
            return

        def _logjournal(self, mask, level, message, detail=None):
            systemd.journal.sendv('MESSAGE=' + message + (' -- {0}'.format(detail) if detail else ''),
                                  'PRIORITY=' + str(level),
                                  'SYSLOG_PID=' + str(os.getpid()),
                                  'SYSLOG_IDENTIFIER=' + self._module)
            return

        def log(self, mask, level, message, detail=None):
            self._initlogger()
            if level > self._LEVEL:
                return
            if not mask&self._MASK:
                return
            if self._QUIET > 1:
                return

            with self._lock:
                self._logwrite(mask, level, message, detail)
            #
            # In this stub we do not support logging to the database
            # (database logging is deprecated, and probably a bad
            # idea on most real world implementations anyway)
            #
            #if self._DBLOG:
            #    self._logdatabase(mask, level, message, detail)

        def _argparseinput(self):
            opts = self._parser.parse_args()
            if opts.quiet:
                self._QUIET = opts.quiet
            if opts.enable_dblog:
                self._DBLOG = opts.enable_dblog
            if opts.loglevel:
                self._LEVEL = getattr(self, opts.loglevel)
                if self._LEVEL is None:
                    self._LEVEL = LOGLEVEL.INFO
            if opts.verbose:
                vlist = ('IMPORTANT', 'GENERAL', 'RECORD', 'PLAYBACK', 'CHANNEL',
                    'OSD', 'FILE', 'SCHEDULE', 'NETWORK', 'COMMFLAG', 'AUDIO',
                    'LIBAV', 'JOBQUEUE', 'SIPARSER', 'EIT', 'VBI', 'DATABASE',
                    'DSMCC', 'MHEG','UPNP','SOCKET','XMLTV','DVBCAM','MEDIA',
                    'IDLE', 'CHANNELSCAN', 'EXTRA', 'TIMESTAMP')
                for v in opts.verbose.upper().split(','):
                    if v in ('ALL', 'MOST', 'NONE'):
                        self._MASK = getattr(self, v)
                    elif v in vlist:
                        self._MASK |= getattr(self, v)
                    elif (len(v) > 2) and (v[0:2] == 'NO'):
                        if v[2:] in vlist:
                            self._MASK &= self._MASK^getattr(self, v[2:])
            if opts.logpath:
                if self._SYSLOG is not None:
                    self._SYSLOG.closelog()
                    self._SYSLOG = None
                if self._LOGSTREAM is not None:
                    self._LOGSTREAM.close()
                    self._LOGSTREAM = None
                fn = os.path.join(opts.logpath, '{0}.{1}.{2}.log'.format(self._module,
                                    datetime.datetime.now().strftime('%Y%m%d%H%M%S'),
                                    os.getpid()))
                self._LOGSTREAM = io.open(fn, 'w')
                self._logwrite = self._logstream
            if opts.syslog:
                if self._LOGSTREAM is not None:
                    self._LOGSTREAM.close()
                    self._LOGSTREAM = None
                self._logwrite = self._logsyslog
                self._SYSLOG = opts.syslog
                syslog.openlog(self._module, logoption=syslog.LOG_PID|syslog.LOG_NDELAY, facility=getattr(syslog, 'LOG_' + opts.syslog))
            if opts.journal:
                if self._SYSLOG is not None:
                    self._SYSLOG.closelog()
                    self._SYSLOG = None
                if self._LOGSTREAM is not None:
                    self._LOGSTREAM.close()
                    self._LOGSTREAM = None
                self._logwrite = self._logjournal

        def loadArgParse(self, parser):
            self._parser = parser
            self._parseinput = self._argparseinput
            parser.add_argument('--quiet', '-q', action='count', default=0, dest='quiet',
                        help='Run quiet.')
            parser.add_argument('--verbose', '-v', type=str.lower, dest='verbose', default='general',
                        help='Specify log verbosity')
            parser.add_argument('--enable-dblog', action='store_true', dest='enable_dblog', default=False,
                        help='Specify logging to the database.')
            parser.add_argument('--loglevel', action='store', type=str.upper, dest='loglevel', default='info',
                        choices=['ANY', 'EMERG', 'ALERT', 'CRIT', 'ERR', 'WARNING', 'NOTICE', 'INFO', 'DEBUG', 'UNKNOWN'],
                        help='Specify log verbosity, using standard syslog levels.')
            parser.add_argument('--logpath', action='store', type=str, dest='logpath',
                        help='Specify directory to log to, filename will be automatically decided.')
            parser.add_argument('--syslog', action='store', type=str.upper, dest='syslog',
                        choices=['AUTH', 'AUTHPRIV', 'CRON', 'DAEMON', 'KERN', 'LPR', 'MAIL', 'NEWS',
                                 'SYSLOG', 'USER', 'UUCP', 'LOCAL0', 'LOCAL1', 'LOCAL2', 'LOCAL3',
                                 'LOCAL4', 'LOCAL5', 'LOCAL6', 'LOCAL7'],
                        help='Specify syslog facility to log to.')
            parser.add_argument('--systemd-journal', action='store_true', dest='journal', default=False,
                        help='Specify systemd-journald logging.')

        def __call__(self, mask, level, message, detail=None):
            self.log(mask, level, message, detail)


class HDHOMERUN_DEFINES(object):

    HDHOMERUN_CHANNELSCAN_PROGRAM_NORMAL       = 0
    HDHOMERUN_CHANNELSCAN_PROGRAM_NODATA       = 1
    HDHOMERUN_CHANNELSCAN_PROGRAM_CONTROL      = 2
    HDHOMERUN_CHANNELSCAN_PROGRAM_ENCRYPTED    = 3
    HDHOMERUN_CONTROL_CONNECT_TIMEOUT          = 2500
    HDHOMERUN_CONTROL_SEND_TIMEOUT             = 2500
    HDHOMERUN_CONTROL_RECV_TIMEOUT             = 2500
    HDHOMERUN_CONTROL_UPGRADE_TIMEOUT          = 30000
    HDHOMERUN_DEBUG_HOST                       = "debug.silicondust.com"
    HDHOMERUN_DEBUG_PORT                       = 8002
    HDHOMERUN_DEBUG_CONNECT_RETRY_TIME         = 30000
    HDHOMERUN_DEBUG_CONNECT_TIMEOUT            = 10000
    HDHOMERUN_DEBUG_SEND_TIMEOUT               = 10000
    HDHOMERUN_DEVICE_MAX_TUNE_TO_LOCK_TIME     = 1500
    HDHOMERUN_DEVICE_MAX_LOCK_TO_DATA_TIME     = 2000
    HDHOMERUN_DEVICE_MAX_TUNE_TO_DATA_TIME     = (HDHOMERUN_DEVICE_MAX_TUNE_TO_LOCK_TIME + HDHOMERUN_DEVICE_MAX_LOCK_TO_DATA_TIME)
    HDHOMERUN_TARGET_PROTOCOL_UDP              = "udp"
    HDHOMERUN_TARGET_PROTOCOL_RTP              = "rtp"
    HDHOMERUN_DISCOVER_MAX_SOCK_COUNT          = 16
    HDHOMERUN_DISCOVER_UDP_PORT                = 65001
    HDHOMERUN_CONTROL_TCP_PORT                 = 65001
    HDHOMERUN_MAX_PACKET_SIZE                  = 1460
    HDHOMERUN_MAX_PAYLOAD_SIZE                 = 1452
    HDHOMERUN_TYPE_DISCOVER_REQ                = 0x0002
    HDHOMERUN_TYPE_DISCOVER_RPY                = 0x0003
    HDHOMERUN_TYPE_GETSET_REQ                  = 0x0004
    HDHOMERUN_TYPE_GETSET_RPY                  = 0x0005
    HDHOMERUN_TYPE_UPGRADE_REQ                 = 0x0006
    HDHOMERUN_TYPE_UPGRADE_RPY                 = 0x0007
    HDHOMERUN_TAG_DEVICE_TYPE                  = 0x01
    HDHOMERUN_TAG_DEVICE_ID                    = 0x02
    HDHOMERUN_TAG_GETSET_NAME                  = 0x03
    HDHOMERUN_TAG_GETSET_VALUE                 = 0x04
    HDHOMERUN_TAG_GETSET_LOCKKEY               = 0x15
    HDHOMERUN_TAG_ERROR_MESSAGE                = 0x05
    HDHOMERUN_TAG_TUNER_COUNT                  = 0x10
    HDHOMERUN_TAG_DEVICE_AUTH_BIN              = 0x29
    HDHOMERUN_TAG_BASE_URL                     = 0x2A
    HDHOMERUN_TAG_DEVICE_AUTH_STR              = 0x2B
    HDHOMERUN_DEVICE_TYPE_WILDCARD             = 0xFFFFFFFF
    HDHOMERUN_DEVICE_TYPE_TUNER                = 0x00000001
    HDHOMERUN_DEVICE_TYPE_STORAGE              = 0x00000005
    HDHOMERUN_DEVICE_ID_WILDCARD               = 0xFFFFFFFF
    HDHOMERUN_MIN_PEEK_LENGTH                  = 4
    HDHOMERUN_STATUS_COLOR_NEUTRAL             = 0xFFFFFFFF
    HDHOMERUN_STATUS_COLOR_RED                 = 0xFFFF0000
    HDHOMERUN_STATUS_COLOR_YELLOW              = 0xFFFFFF00
    HDHOMERUN_STATUS_COLOR_GREEN               = 0xFF00C000
    HDHOMERUN_CHANNELSCAN_MAX_PROGRAM_COUNT    = 64


class ThreadWithReturn(threading.Thread):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._return = None

    def run(self):
        if self._target is not None:
            self._return = self._target(*self._args, **self._kwargs)

    def join(self, *args, **kwargs):
        super().join(*args, **kwargs)
        return self._return


def HDHRDiscoverTunersByCloud(startupDelay=0):

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: making request to SD cloud server for tuner list with delay {}'.format(startupDelay))

    time.sleep(startupDelay)

    discoveredTuners = {}

    SDdiscover = []
    try:
        r = requests.get('https://my.hdhomerun.com/discover', timeout=(4, 1))
        r.raise_for_status()
        SDdiscover = r.json()
    except requests.exceptions.RequestException:
        log(MythLog.GENERAL|MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: request to SD cloud failed')
        return discoveredTuners
    except json.decoder.JSONDecodeError:
        log(MythLog.GENERAL|MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: response from SD cloud was not decodable')
        return discoveredTuners
    else:
        if not isinstance(SDdiscover, list):
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: response from SD cloud was not a list')
            return discoveredTuners

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: processing response from SD cloud: {0}'.format(SDdiscover))

    for device in SDdiscover:
        if not isinstance(device, dict):
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: response from SD cloud was not a list of dicts')
            continue
        Legacy = False
        DeviceID = None
        DiscoverURL = None
        LocalIP = None
        if 'Legacy' in device:
            Legacy = bool(device['Legacy'])
        device['Legacy'] = Legacy
        if 'DeviceID' in device:
            DeviceID = device['DeviceID']
        if 'DiscoverURL' in device:
            DiscoverURL = device['DiscoverURL']
        if 'LocalIP' in device:
            try:
                LocalIP = ipaddress.ip_address(device['LocalIP']).compressed
            except ValueError:
                LocalIP = None

        if (DeviceID is None) or (DiscoverURL is None) or (LocalIP is None):
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: skipped device from SD cloud (not a tuner): {0}'.format(device))
            continue

        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: accepted tuner {0} from SD cloud response'.format(DeviceID))

        discoveredTuners[DeviceID] = device

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByCloud: returning discoved/accepted tuners:{0}'.format(discoveredTuners))

    return discoveredTuners


def HDHRDiscoverTunersByBroadcast(startupDelay=0):

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: performing local broadcast discovery with delay {}'.format(startupDelay))

    time.sleep(startupDelay)

    discoveredTuners = {}

    # Build our discovery packet payload (based on libhdhomerun)
    discoveryPayload = bytearray()
    discoveryPayload.extend(struct.pack('>BBIBBI',
                            HDHOMERUN_DEFINES.HDHOMERUN_TAG_DEVICE_TYPE,
                            4,
                            HDHOMERUN_DEFINES.HDHOMERUN_DEVICE_TYPE_TUNER,
                            HDHOMERUN_DEFINES.HDHOMERUN_TAG_DEVICE_ID,
                            4,
                            HDHOMERUN_DEFINES.HDHOMERUN_DEVICE_ID_WILDCARD))
    # Build our discovery broadcast packet (based on libhdhomerun)
    discoveryPacket = bytearray()
    discoveryPacket.extend(struct.pack('>H', HDHOMERUN_DEFINES.HDHOMERUN_TYPE_DISCOVER_REQ))
    discoveryPacket.extend(struct.pack('>H', len(discoveryPayload)))
    discoveryPacket.extend(discoveryPayload)
    discoveryPacket.extend(struct.pack('<I', zlib.crc32(discoveryPacket) & 0xffffffff))

    # Send discovery packet, and process replies
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.settimeout(.1)
    for i in range(2):
        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: sending hdhomerun broadcast discovery packet')
        try:
            sock.sendto(discoveryPacket, ('<broadcast>', HDHOMERUN_DEFINES.HDHOMERUN_DISCOVER_UDP_PORT))
        except OSError as e:
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: error in sendto: {}'.format(e))
            continue
        start = time.time()
        while ((time.time() - start) < .2):
            try:
                (responsePacket, addr) = sock.recvfrom(2048)
            except socket.timeout:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: timeout waiting for response to broadcast discovery')
                continue
            except OSError as e:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: error in recvfrom: {}'.format(e))
                continue
            else:
               log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: received reply from broadcast discovery')
            if not isinstance(addr, tuple):
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet addr is not a tuple')
                continue
            if len(addr) == 0:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet addr has no elements')
                continue
            if responsePacket is None:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet did not have a payload')
                continue
            if len(responsePacket) > HDHOMERUN_DEFINES.HDHOMERUN_MAX_PACKET_SIZE:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet too big')
                continue
            if len(responsePacket) < 8:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet too small')
                continue
            if struct.unpack_from('>H', responsePacket, offset=0)[0] != HDHOMERUN_DEFINES.HDHOMERUN_TYPE_DISCOVER_RPY:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet is not a reply')
                continue
            if (zlib.crc32(responsePacket[:-4]) & 0xffffffff) != (struct.unpack_from('<I', responsePacket, offset=-4)[0]):
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response crc is bad')
                continue
            responsePayloadLength = struct.unpack_from('>H', responsePacket, offset=2)[0]
            if len(responsePacket) != (8 + responsePayloadLength):
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload length inconsistent with packet length')
                continue

            responsePayload = responsePacket[4:-4]
            responsePayloadPointer = 0
            DeviceID = None
            BaseURL = None
            DiscoverURL = None
            LocalIP = None
            Legacy = False

            while (responsePayloadPointer <= (responsePayloadLength - 2)):
                tag, vlen = struct.unpack_from('>BB', responsePayload, offset=responsePayloadPointer)[0:2]
                if tag == HDHOMERUN_DEFINES.HDHOMERUN_TAG_DEVICE_TYPE:
                    if vlen != 4:
                        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload device type not proper length')
                        break
                    if (responsePayloadLength - responsePayloadPointer - 2) < vlen:
                        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload device type length exceeds payload')
                        break
                    value = struct.unpack_from('>I',responsePayload, offset=responsePayloadPointer+2)[0]
                    if value != HDHOMERUN_DEFINES.HDHOMERUN_DEVICE_TYPE_TUNER:
                        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload device type was not tuner')
                        break
                if tag == HDHOMERUN_DEFINES.HDHOMERUN_TAG_DEVICE_ID:
                    if vlen != 4:
                        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload device id not proper length')
                        break
                    if (responsePayloadLength - responsePayloadPointer - 2) < vlen:
                        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload device id length exceeds payload')
                        break
                    value = struct.unpack_from('>I',responsePayload, offset=responsePayloadPointer+2)[0]
                    DeviceID = '{:02X}'.format(value)
                if tag == HDHOMERUN_DEFINES.HDHOMERUN_TAG_BASE_URL:
                    if (responsePayloadLength - responsePayloadPointer- 2) < vlen:
                        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload baseurl length exceeds payload')
                        break
                    BaseURL = responsePayload[responsePayloadPointer+2:responsePayloadPointer+2+vlen].decode("utf-8") 
                    DiscoverURL = BaseURL  + '/discover.json'
                responsePayloadPointer += (2 + vlen)

            try:
                LocalIP = ipaddress.ip_address(addr[0]).compressed
            except ValueError:
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response packet source address was not decodable')
                continue

            # Determine if legacy device (based on libhdhomerun coding)
            if DeviceID is not None:
                if DeviceID[0:3] in ['101', '102', '103', '111', '121', '122'] or \
                   DeviceID[0:4] in ['1000', '1001', '1002', '1003', '1200', '1201', '1202']:
                    Legacy = True

            if (LocalIP is None) or (DeviceID is None) or (BaseURL is None) or (DiscoverURL is None):
                log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: response payload was incomplete')
                continue

            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: accepted tuner {0} from local broadcast response'.format(DeviceID))

            discoveredTuners[DeviceID] = {'DeviceID':DeviceID, 'BaseURL':BaseURL, 'DiscoverURL':DiscoverURL, 'LocalIP':LocalIP, 'Legacy':Legacy}

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverTunersByBroadcast: returning discoved/accepted tuners:{0}'.format(discoveredTuners))

    return discoveredTuners


def HDHRDiscoverLineup(discoverURL):

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: performing discovery with {}'.format(discoverURL))

    discoverResponse = {}

    try:
        r = requests.get(discoverURL, timeout=(4, 1))
        r.raise_for_status()
        discoverResponse = r.json()
    except requests.exceptions.RequestException:
        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: request to tuner for discover failed')
        discoverResponse = {}
    except json.decoder.JSONDecodeError:
        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: response tuner was not decodeable')
        discoverResponse = {}
    else:
        if not isinstance(discoverResponse, dict):
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: response was not a dict')
            discoverResponse = {}

    Legacy = False
    DeviceID = None
    LineupURL = None
    BaseURL = None
    if 'Legacy' in discoverResponse:
        Legacy = bool(discoverResponse['Legacy'])
    if 'DeviceID' in discoverResponse:
        DeviceID = discoverResponse['DeviceID']
    if 'LineupURL' in discoverResponse:
        LineupURL = discoverResponse['LineupURL']
    if 'BaseURL' in discoverResponse:
        BaseURL = discoverResponse['BaseURL']
    else:
        parsedURL = urllib.parse.urlparse(discoverURL)
        BaseURL = parsedURL.scheme + '://' + parsedURL.netloc

    if (Legacy) or (DeviceID is None) or (LineupURL is None):
        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: Device with discoverURL ' + discoverURL + ' is not a supported tuner'.format())
        return {'DeviceID': DeviceID, 'LineupURL': LineupURL, 'BaseURL': BaseURL, 'Legacy': Legacy, 'Lineup': None}

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: requesting lineup from tuner')

    hdhrLineup = []

    try:
        r = requests.get(LineupURL, timeout=(4, 1))
        r.raise_for_status()
        hdhrLineup = r.json()
    except requests.exceptions.RequestException:
        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: request to tuner for lineup failed')
        discoverResponse['Lineup'] = None
        return
    except json.decoder.JSONDecodeError:
        log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: response from tuner for lineup was not decodable')
        discoverResponse['Lineup'] = None
        return
    else:
        if not isinstance(hdhrLineup, list):
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: response from tuner for lineup was not a list')
            discoverResponse['Lineup'] = None
            return

    lineupList = []

    for hdhrChannel in hdhrLineup:
        channelData = {}
        if 'GuideNumber' not in hdhrChannel:
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: GuideNumber not in lineup response')
            continue
        if 'URL' not in hdhrChannel:
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: URL not in lineup response')
            continue
        try:
            guidenumber = channelNormalize(hdhrChannel['GuideNumber'])
        except TypeError:
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: GuideNumber is malformed')
            continue
        favorite = False
        if 'Favorite' in hdhrChannel:
            favorite = bool(hdhrChannel['Favorite'])
        channelData['Favorite'] = favorite
        channelData['GuideNumber'] = hdhrChannel['GuideNumber']
        channelData['URL'] = hdhrChannel['URL']
        lineupList.append(channelData)

    discoverResponse['Lineup'] = lineupList

    log(MythLog.RECORD, MythLog.DEBUG, 'HDHRDiscoverLineup: discoverResponse: {}'.format(discoverResponse))

    return discoverResponse


def HDHRBackgroundDiscovery():

    # In order to select the tuners, we first need to do device discovery
    # to determine the device ids and IP addresses.  To reduce the startup
    # time, perform tuner discovery in parallel
    discoveredTuners = {}
    discoverThreads = []

    discoverThreads.append(ThreadWithReturn(target=HDHRDiscoverTunersByCloud, args=(), kwargs={}))
    discoverThreads[-1].start()
    discoverThreads.append(ThreadWithReturn(target=HDHRDiscoverTunersByCloud, args=(), kwargs={'startupDelay': 0.5}))
    discoverThreads[-1].start()
    discoverThreads.append(ThreadWithReturn(target=HDHRDiscoverTunersByBroadcast, args=(), kwargs={}))
    discoverThreads[-1].start()
    discoverThreads.append(ThreadWithReturn(target=HDHRDiscoverTunersByBroadcast, args=(), kwargs={'startupDelay': 0.3}))
    discoverThreads[-1].start()

    for t in discoverThreads:
        r = t.join()
        if not isinstance(r, dict):
            log(MythLog.RECORD, MythLog.ERR, "Invalid response from discover request: {}".format(r))
            continue
        discoveredTuners.update(r)

    # Due to the need to allow invokation by IP address (without a
    # known device id) we match and then add to the eligible list
    # by IP index
    eligibleTuners = {}

    if args.hdhr is None:
        # Add all discovered HDHRs
        for tuner in discoveredTuners:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Requesting lineup from discovered tuner at {0}'.format(discoveredTuners[tuner]['LocalIP']))
            eligibleTuners[discoveredTuners[tuner]['LocalIP']] = discoveredTuners[tuner]
    else:
        for hdhr in args.hdhr:
            if re.match('^[0-9A-Z]{8}$', hdhr.upper()):    # deviceid?
                found = False
                for tuner in discoveredTuners:
                    if discoveredTuners[tuner]['DeviceID'] == hdhr.upper():
                        log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Requesting lineup from discovered tuner specified by deviceid {0} at {1}'.format(discoveredTuners[tuner]['DeviceID'], discoveredTuners[tuner]['LocalIP']))
                        eligibleTuners[discoveredTuners[tuner]['LocalIP']] = discoveredTuners[tuner]
                        found = True
                        break
                if not found:
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.NOTICE, 'Unable to add tuner specified by deviceid {0} because it was not discovered'.format(hdhr.upper()))
            else:                                          # possible IP or dns
                try:
                    ip = ipaddress.ip_address(socket.getaddrinfo(hdhr, None)[0][4][0]).compressed
                except (socket.error, ValueError):
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Unable to add tuner specified by ip {0} because the address could not be resolved'.format(hdhr))
                else:
                    found = False
                    for tuner in discoveredTuners:
                        if discoveredTuners[tuner]['LocalIP'] == ip:
                            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Requesting lineup from discovered tuner specified by ip at {0}'.format(discoveredTuners[tuner]['LocalIP']))
                            eligibleTuners[discoveredTuners[tuner]['LocalIP']] = discoveredTuners[tuner]
                            found = True
                            break
                    if found is False:
                        log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Requesting lineup from undiscovered tuner specified by ip at {0} by explicit user request'.format(ip))
                        # Need to try to contact the HDHR and see if it is possible to obtain info
                        eligibleTuners[ip] = {'LocalIP': ip, 'BaseURL': 'http://' + ip + ':80', 'DiscoverURL': 'http://' + ip + ':80/discover.json'}

    # For each eligibleTuners we want to get the list of channels to
    # feed to our reader thread
    discoverLineupThreads = []

    for tuner in eligibleTuners:
        if 'DiscoverURL' not in eligibleTuners[tuner]:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, "Skipping tuner " + eligibleTuners[tuner] + " because no discoverURL")
            continue
        Legacy = False
        if 'Legacy' in eligibleTuners[tuner]:
            Legacy = bool(eligibleTuners[tuner]['Legacy'])
        if Legacy:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Tuner at {} is an unsupported legacy tuner'.format(eligibleTuners[tuner]['BaseURL']))
            continue
        discoverLineupThreads.append(
                ThreadWithReturn(target=HDHRDiscoverLineup, args=(eligibleTuners[tuner]['DiscoverURL'],)))
        discoverLineupThreads[-1].start()

    # Process the response(s) and add lineups to our reader thread
    while (len(discoverLineupThreads) > 0):
        for i in range(len(discoverLineupThreads) - 1, -1, -1):
            if not discoverLineupThreads[i].isAlive():
                r = discoverLineupThreads[i].join()
                if not isinstance(r, dict):
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'Invalid response from lineup request: {}'.format(r))
                else:
                    if r['Lineup'] is None:
                        log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Request for lineup from tuner at {} failed'.format(r['BaseURL']))
                    else:
                        log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Adding {} channels from tuner at {}'.format(len(r['Lineup']), r['BaseURL']))
                        TSReader.addHDHRLineup(r['Lineup'])
                del discoverLineupThreads[i]
        if (len(discoverLineupThreads) > 0):
            log(MythLog.RECORD, MythLog.DEBUG, 'HDHRBackgroundDiscovery: Waiting for completion of discoverLineup threads')
            time.sleep(.1)


def channelNormalize(channel):

    m0 = re.match('^(\d+)$', channel)
    m1 = re.match('^(\d+)\.(\d+)$', channel)
    m2 = re.match('^(\d+)_(\d+)$', channel)
    m3 = re.match('^(\d+)-(\d+)$', channel)
    if m0:
        return '{0}'.format(int(m0.group(1)))
    elif m1:
        return '{0}.{1}'.format(int(m1.group(1)), int(m1.group(2)))
    elif m2:
        return '{0}.{1}'.format(int(m2.group(1)), int(m2.group(2)))
    elif m3:
        return '{0}.{1}'.format(int(m3.group(1)), int(m3.group(2)))
    raise TypeError('Invalid channel: {0}'.format(channel))


def CommandResponse(serial, response):
    if serial is not None:
        response = serial + ':' + response
    log(MythLog.RECORD, MythLog.DEBUG, 'command reply: {0}'.format(response))
    sys.stderr.write(response + '\n')
    sys.stderr.flush()
    return


class TransportStreamWriterThread(object):

    def __init__(self, FIFO=None, flowcontrol='XON/XOFF', blocksize=6160384, interval=.1, MythLog=None):
        self._FIFO = FIFO
        if flowcontrol == 'XON/XOFF':
            self._flowcontrol = flowcontrol
            self._streaming = True
        elif flowcontrol == 'Polling':
            self._flowcontrol = flowcontrol
            self._streaming = False
        else:
            raise ValueError('flowcontrol {0} must be XON/OFF or Polling'.format(flowcontrol))
        try:
            self._interval = float(interval)
        except ValueError:
            raise ValueError('interval {0} is not a valid float'.format(interval))
        try:
            self._blocksize = int(blocksize)
        except:
            raise ValueError('blocksize {0} is not a valid integer'.format(blocksize))
        if self._blocksize < 1:
            raise ValueError('blocksize {0} must be greater than zero'.format(blocksize))
        self._work = threading.Event()
        self._lock = threading.Lock()
        self._running = True
        self._logger = MythLog
        thread = threading.Thread(target=self.run, args=())
        thread.daemon = True
        thread.start()

    def _log(self, mask, level, message, detail=None):
        if self._logger is not None:
            self._logger(mask, level, message, detail)

    def close(self):
        self._running = False
        self._streaming = False
        self._work.set()

    def pause(self):
        if self._flowcontrol != 'XON/XOFF':
            raise TypeError('Recorder is not in XON/XOFF flow control mode')
        self._streaming = False
        self._work.set()

    def resume(self):
        if self._flowcontrol != 'XON/XOFF':
            raise TypeError('Recorder is not in XON/XOFF flow control mode')
        self._streaming = True
        self._work.set()

    def flowControl(self):
        return self._flowcontrol

    def blockSize(self, blocksize=None):
        if blocksize is not None:
            try:
                size = int(blocksize)
            except ValueError:
                raise ValueError('BlockSize {0} is not a valid integer'.format(blocksize))
            if size < 1:
                raise ValueError('BlockSize {0} must be greater than zero'.format(blocksize))
            self._blocksize = size
        return self._blocksize

    def sendBytes(self):
        if self._flowcontrol != 'Polling':
            raise TypeError('Recorder is not in Polling flow control mode')
        self._streaming = True
        self._work.set()
        return True

    def run(self):
        bytes = bytearray()
        while self._running:
            self._work.wait(self._interval)
            self._work.clear()
            while (self._streaming):
                if self._flowcontrol == 'Polling':
                    self._streaming = False
                while (len(bytes) < self._blocksize):
                    try:
                        chunk = self._FIFO.get(block=False)
                    except queue.Empty:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'stream FIFO queue empty')
                        break
                    else:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'stream FIFO queue block retrieved, size={0}'.format(len(chunk)))
                        bytes.extend(chunk)
                if len(bytes) == 0:
                    break
                sendlen = min(self._blocksize, len(bytes))
                sentlen = sys.stdout.buffer.write(bytes[0:sendlen])
                sys.stdout.flush()
                if sentlen < 0:
                    self._log(MythLog.RECORD, MythLog.ERR, 'error {} while writing to stdout'.format(sentlen))
                    break
                else:
                    self._log(MythLog.RECORD, MythLog.DEBUG, 'wrote {} bytes to stdout, {} accepted'.format(sendlen, sentlen))
                    if sentlen == 0:
                        break
                    elif sentlen == len(bytes):
                        bytes.clear()
                    else:
                        bytes = bytes[sentlen:]


class TransportStreamReaderThread(object):

    def __init__(self, FIFO=None, interval=.2, MythLog=None):
        self._FIFO = FIFO
        self._interval = interval
        self._channels = dict()
        self._stream = None
        self._streaming_stop = 0
        self._streaming_stop_delay = .50
        self._lock = threading.Lock()
        self._state = None
        self._channel = None
        self._work = threading.Event()
        self._chunksize = 1316 * 40
        self._lta = 1
        self._running = True
        self._logger = MythLog
        thread = threading.Thread(target=self.run, args=())
        thread.daemon = True
        thread.start()

    def _log(self, mask, level, message, detail=None):
        if self._logger is not None:
            self._logger(mask, level, message, detail)

    def addHDHRLineup(self, lineup):
        self._log(MythLog.RECORD, MythLog.DEBUG, 'process add {}'.format(lineup))
        for channel in lineup:
            if 'GuideNumber' not in channel:
                continue
            if 'URL' not in channel:
                continue
            try:
                guidenumber = channelNormalize(channel['GuideNumber'])
            except TypeError:
                continue
            favorite = False
            if 'Favorite' in channel:
                favorite = bool(channel['Favorite'])
            if guidenumber not in self._channels:
                self._channels[guidenumber] = list()
            if favorite:
                self._channels[guidenumber].insert(0, channel['URL'])
            else:
                self._channels[guidenumber].append(channel['URL'])

    def start(self):
        with self._lock:
            self._streaming_stop = None
        self._work.set()

    def stop(self):
        with self._lock:
            self._streaming_stop = time.time() + self._streaming_stop_delay
        self._work.set()

    def close(self):
        with self._lock:
            if self._stream:
                try:
                    self._stream.connection.close()
                except (requests.exceptions.RequestException, AttributeError):
                    pass
            self._stream = None
            self._channel = None
            self._state = None
        self._running = False
        self._work.set()

    def hasTuner(self):
        return True

    def tuneChannel(self, channel):
        c = channelNormalize(channel)
        if c not in self._channels:
            with self._lock:
                if self._stream:
                    try:
                        self._stream.connection.close()
                    except (requests.exceptions.RequestException, AttributeError):
                        pass
                self._stream = None
                self._channel = None
                self._state = None
                while True:
                    try:
                        chunk = self._FIFO.get(block=False)
                    except queue.Empty:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'tuneChannel stream FIFO queue emptying complete')
                        break
                    else:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'tuneChannel stream FIFO queue emptying block retrieved, size={0}'.format(len(chunk)))
            raise ValueError('Channel {0} not available'.format(c))
        with self._lock:
            if (self._channel == c) and (self._state == 'Streaming') and (self._stream is not None):
                self._log(MythLog.RECORD, MythLog.DEBUG, 'tuneChannel request to same channel {0} while streaming ignored'.format(c))
            else:
                if self._stream:
                    try:
                        self._stream.connection.close()
                    except (requests.exceptions.RequestException, AttributeError):
                        pass
                self._stream = None
                self._channel = c
                self._state = 'Tuning'
                while True:
                    try:
                        chunk = self._FIFO.get(block=False)
                    except queue.Empty:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'tuneChannel stream FIFO queue emptying complete')
                        break
                    else:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'tuneChannel stream FIFO queue emptying block retrieved, size={0}'.format(len(chunk)))
        self._work.set()

    def getChannel(self):
        if (self._stream is None) or (self._state is not 'Streaming'):
            return None
        return self._channel

    def hasPictureAttributes(self):
        return False

    def setBrightness(self, brightness):
        raise TypeError('Recorder does not support PictureAttributes')

    def setContrast(self, contrast):
        raise TypeError('Recorder does not support PictureAttributes')

    def setColour(self, colour):
        raise TypeError('Recorder does not support PictureAttributes')

    def setHue(self, hue):
        raise TypeError('Recorder does not support PictureAttributes')

    def hasLock(self):
        return self._state == 'Streaming'

    def isTuning(self):
        return self._state == 'Tuning';

    def isStreaming(self):
        return self._state == 'Streaming';

    def getConnectionAddresses(self):
        if (self._stream is None) or (self._state is not 'Streaming'):
            return None
        try:
            sockname = self._stream.raw._original_response.fp.raw._sock.getsockname()
            peername = self._stream.raw._original_response.fp.raw._sock.getpeername()
            return([sockname[0], sockname[1], peername[0], peername[1]])
        except (requests.exceptions.RequestException, socket.error, IndexError, TypeError):
            return None

    def run(self):
        while self._running:
            self._work.wait(self._interval)
            self._work.clear()
            if self._state == 'Tuning':
                # for each device with channel
                # try sequentially
                for url in self._channels[self._channel]:
                    try:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'trying tuning with url: {0}'.format(url))
                        self._stream = requests.get(url, stream=True, timeout=(4, 30))
                        self._stream.raise_for_status()
                        try:
                            sockname = self._stream.raw._original_response.fp.raw._sock.getsockname()
                            peername = self._stream.raw._original_response.fp.raw._sock.getpeername()
                            self._log(MythLog.RECORD, MythLog.DEBUG,
                                'tuning succeeded.  Local socket address {}:{}, remote socket address {}:{}'.
                                format(sockname[0], sockname[1], peername[0], peername[1]))
                        except (requests.exceptions.RequestException, socket.error, IndexError, TypeError):
                            self._log(MythLog.RECORD, MythLog.DEBUG, 'tuning succeeded (socket information unavailable)')
                        with self._lock:
                            self._state = 'Streaming'
                            self._chunksize = 1316 * 40
                            self._lta = 1
                        break
                    except requests.exceptions.RequestException:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'tuning failed')
                        continue
                if self._state != 'Streaming':
                    self._log(MythLog.RECORD, MythLog.DEBUG, 'tuning failed on all eligible devices')
                    with self._lock:
                        if self._stream:
                            try:
                                self._stream.connection.close()
                            except (requests.exceptions.RequestException, AttributeError):
                                pass
                        self._stream = None
                        self._channel = None
                        self._state = None
            if self._state == 'Streaming':
                while self._running:
                    start = time.time()
                    self._log(MythLog.RECORD, MythLog.DEBUG, 'trying to read stream block')
                    try:
                        chunk = self._stream.raw.read(self._chunksize)
                    except (requests.exceptions.RequestException, AttributeError):
                        break
                    if not chunk:
                        break
                    if self._state != 'Streaming':
                        break
                    self._log(MythLog.RECORD, MythLog.DEBUG, 'stream block read, size={0}'.format(len(chunk)))
                    # Try a bit of adaptive chunk sizing (targeting between .5 and 1 secs),
                    # limited to the "magic" 769860 (which is a multiple of 1316 which is
                    # good for the HDHR, but less than MythTV's "TOO_FAST_SIZE" value which
                    # forces start/stop mode)
                    chunksize = self._chunksize
                    interval = time.time() - start
                    self._lta = ((self._lta * 3) + interval) / 4
                    if self._lta < 0.25:
                        self._chunksize = min(769860, (1316 * ((self._chunksize * 2) // 1316)))
                    elif self._lta > 1.5:
                        self._chunksize = max(1316, (1316 * ((self._chunksize // 2) // 1316)))
                    elif self._lta < 0.5:
                        self._chunksize = min(769860, (1316 * (int(self._chunksize * 1.10) // 1316)))
                    elif self._lta > 1.0:
                        self._chunksize = max(1316, (1316 * (int(self._chunksize * 0.9) // 1316)))
                    else:
                        pass
                    if chunksize != self._chunksize:
                        self._log(MythLog.RECORD, MythLog.DEBUG, 'stream read block size changed from {0} to {1}'.format(chunksize, self._chunksize))

                    # If not streaming, throw the bytes away
                    if self._streaming_stop is not None and self._streaming_stop < start:
                        break

                    try:
                        self._FIFO.put(chunk, block=False)
                    except queue.Full:
                        # Try to make room by removing oldest.
                        lost = bytes()
                        try:
                            lost = self._FIFO.get(block=False)
                        except queue.Empty:
                            pass
                        else:
                            self._log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'stream FIFO queue full, dropped chunk of {0} bytes'.format(len(lost)))
                            try:
                                self._FIFO.put(chunk, block=False)
                            except queue.Full:
                                self._log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'stream FIFO queue still full, unable to append chunk of {0} bytes'.format(len(chunk)))
            else:
                pass


if __name__ == '__main__':

    VERSION = 4.0              # This recorders version number (arbitrary value)
    APIVERSION = 1             # Current API Version
    MAXAPIVERSION = 2          # Maximum API Version this recorder supports

    # Instantiate logging
    log = MythLog(os.path.basename(sys.argv[0]))

    # Parse our args
    parser = argparse.ArgumentParser()
    parser.add_argument('--hdhr', action='append', type=str, dest='hdhr',
                        help='the HDHomeRun(s) from which to stream')
    parser.add_argument('--queuesize', action='store', type=int, default=100, dest='queuesize',
                        help='Specify the internal fifo stream size')
    parser.add_argument('--devicename', '--devname', '-d', action='store', type=str, dest='devicename', default='',
                        help='unique devicename for ExternalRecorder')
    parser.add_argument('--inputid', action='store', type=str, dest='inputid', default='',
                        help='unique inputid for ExternalRecorder')

    log.loadArgParse(parser)

    args = parser.parse_args()

    log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Recorder starting, args: {0}'.format(' '.join(sys.argv[1:])))

    # Create our FIFO transport stream buffer
    TransportStreamFIFO = queue.Queue(maxsize=args.queuesize)

    # Start our writer and reader threads
    TSWriter = TransportStreamWriterThread(TransportStreamFIFO, MythLog=log)
    TSReader = TransportStreamReaderThread(TransportStreamFIFO, MythLog=log)

    # Start HDHR discovery in the background
    HDHRBackgroundDiscoveryThread = threading.Thread(target=HDHRBackgroundDiscovery)
    HDHRBackgroundDiscoveryThread.start()



    # Main loop (reading commands)

    while True:

        try:
            command = sys.stdin.readline()
        except KeyboardInterrupt:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'Keyboard Interrupt, closing recorder')
            break
        except IOError as e:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'IOError reading stdin ({}: {}), closing recorder'.format(e.errno, e.strerror))
            break
        except Exception as e:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'Error reading stdin, aborting: ' + sys.exc_info()[0])
            break
        if not command:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'EOF reading stdin, closing recorder')
            break
        command = command.rstrip('\n')

        log(MythLog.RECORD, MythLog.DEBUG, 'command received: {0}'.format(command))

        if (APIVERSION > 1):
            serial = None
            cmd = None
            try:
                serial, cmd = command.split(':', 1)
            except ValueError:
                cmd = ''
            if (serial is None) or (cmd is None):
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'command received is not in API version 2 format: {0}'.format(command))
                if serial is None:
                     serial = '0'
                CommandResponse(serial, 'ERR:API Version 2 requires serial number')
                continue
        else:
            serial = None
            cmd = command

        if (cmd == 'APIVersion?'):
            APIVERSION = MAXAPIVERSION
            CommandResponse(serial, 'OK:' + str(APIVERSION))
        elif (cmd.startswith('APIVersion:')):
            value = None
            try:
                value = int(cmd[11:])
            except ValueError:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'APIVersion is not an integer')
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                if (value > MAXAPIVERSION):
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'APIVersion specified (' + str(value) + ') is higher than supported (' + str(MAXAPIVERSION) + ')')
                    CommandResponse(serial, 'ERR:APIVersion specified (' + str(value) + ') is higher than supported (' + str(MAXAPIVERSION) + ')')
                elif (value < 1):
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'APIVersion specified (' + str(value) + ') is lower than one')
                    CommandResponse(serial, 'ERR:APIVersion specified (' + str(value) + ') is lower than one')
                else:
                    APIVERSION = value
                    CommandResponse(serial, 'OK:' + str(APIVERSION))
        elif (cmd == 'Version?'):
            CommandResponse(serial, 'OK:' + str(VERSION))
        elif (cmd == 'Description?'):
            description = os.path.basename(sys.argv[0])
            description += ' (pid #{})'.format(os.getpid())
            if TSReader.hasLock():
                channel = TSReader.getChannel()
                if channel is not None:
                    description += ' streaming channel {}'.format(channel)
                connectionAddresses = TSReader.getConnectionAddresses()
                if connectionAddresses is not None:
                    description += ' from {}'.format(connectionAddresses[2])
            CommandResponse(serial, 'OK:' + description)
        elif (cmd == 'HasPictureAttributes?'):
            if TSReader.hasPictureAttributes():
                CommandResponse(serial, 'OK:Yes')
            else:
                CommandResponse(serial, 'OK:No')
        elif (cmd.startswith('SetBrightness:')):
            value = cmd[14:]
            try:
                TSReader.setBrightness(value)
            except (ValueError, TypeError) as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'SetBrightness request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd.startswith('SetContrast:')):
            value = cmd[12:]
            try:
                TSReader.setContrast(value)
            except (ValueError, TypeError) as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'SetContrast request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd.startswith('SetColour:')):
            value = cmd[10:]
            try:
                TSReader.setColour(value)
            except (ValueError, TypeError) as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'SetColour request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd.startswith('SetHue:')):
            value = cmd[7:]
            try:
                TSReader.setHue(value)
            except (ValueError, TypeError) as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'SetHue request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd == 'FlowControl?'):
            CommandResponse(serial, 'OK:{0}'.format(TSWriter.flowControl()))
        elif (cmd == 'HasTuner?'):
            if TSReader.hasTuner():
                CommandResponse(serial, 'OK:Yes')
            else:
                CommandResponse(serial, 'OK:No')
        elif (cmd.startswith('TuneChannel:')):
            channel = cmd[12:]
            start = time.time()                # If needed, wait for for discovery to complete
            while(((time.time() - start) < 10) and (HDHRBackgroundDiscoveryThread.isAlive())):
                log(MythLog.RECORD, MythLog.DEBUG, 'Waiting for HDHR discovery to complete before processing TuneChannel')
                time.sleep(.1)
            try:
                TSReader.tuneChannel(channel)
            except (ValueError, TypeError) as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'Tuning request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Tuning request for channel {0} accepted'.format(channel))
                CommandResponse(serial, 'OK')
        elif (cmd == 'LockTimeout?'):
            CommandResponse(serial, 'OK:10000')
        elif (cmd == 'SignalStrengthPercent?'):
            if TSReader.hasLock():
                CommandResponse(serial, 'OK:100')
            else:
                CommandResponse(serial, 'OK:0')
        elif (cmd == 'IsOpen?'):
            CommandResponse(serial, 'OK:Open')
        elif (cmd == 'HasLock?'):
            if TSReader.hasLock():
                connectionAddresses = TSReader.getConnectionAddresses()
                if connectionAddresses is not None:
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO,
                        'Tuning successful, connection {}:{} -> {}:{}'.
                        format(connectionAddresses[0], connectionAddresses[1],
                               connectionAddresses[2], connectionAddresses[3]))
                else:
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Tuning successful')
                CommandResponse(serial, 'OK:Yes')
            else:
                if TSReader.isTuning():
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Tuning in progress')
                else:
                    log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'Tuning failed')
                CommandResponse(serial, 'OK:No')
        elif (cmd == 'StartStreaming'):
            TSReader.start()
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Streaming started')
            CommandResponse(serial, 'OK:Started')
        elif (cmd == 'StopStreaming'):
            TSReader.stop()
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Streaming stopped')
            CommandResponse(serial, 'OK:Stopped')
        elif (cmd == 'XON'):
            try:
                TSWriter.resume()
            except TypeError as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'XON request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd == 'XOFF'):
            try:
                TSWriter.pause()
            except TypeError as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'XOFF request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd.startswith('BlockSize:')):
            blocksize = cmd[10:]
            try:
                TSWriter.blockSize(blocksize)
            except ValueError as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'BlockSize request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd == 'SendBytes'):
            try:
                TSWriter.sendBytes()
            except TypeError as e:
                log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'SendBytes request failed:' + str(e))
                CommandResponse(serial, 'ERR:' + str(e))
            else:
                CommandResponse(serial, 'OK')
        elif (cmd == 'CloseRecorder'):
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Recorder stopping')
            CommandResponse(serial, 'OK:Terminating')
            break
        else:
            log(MythLog.GENERAL|MythLog.RECORD, MythLog.ERR, 'Invalid command received from ExternalRecorder: {0}'.format(cmd))
            CommandResponse(serial, 'ERR:Unknown command {0}'.format(cmd))

    TSWriter.close()
    TSReader.close()
    log(MythLog.GENERAL|MythLog.RECORD, MythLog.INFO, 'Recorder stopped')





# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
